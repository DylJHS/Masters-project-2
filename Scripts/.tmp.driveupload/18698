---
title: "RNA Inpupt"
output: html_document
date: "2024-04-30"
Note: This script is for the formatting of the input RNAseq for the model.
---

CONTENTS:

1\. SETUP

1.1. ROOT DIRECTORY SETTINGS

1.2. PACKAGES

1.4. RESUABLE FUNCTIONS

2\. DATA COLLECTION

2.1. LOADING THE DATA

3\. CLEANING AND PRE-PROCESSING

3.1. RE-TRANSFORMATION OF THE COUNT DATA

3.2. GENE ID TO NAME CONVERSION

3.3. SAMPLE TO ID CONVERSION

3.4. GENE & SAMPLE TRIMMING

4\. PROCESSING

4.1. DGE MODELLING

4.2. CREATE THE SAMPLE FACTORS

4.3. TRIM LOW COUNT GENES

4.4. PLOT THE MDS OF THE FACTORS

4.5. CREATE THE LINEAR MODEL

5\. COMPLETE RESULTS

5.1. PRODUCE THE RESULTS TABLE

5.2. CREATE THE VOLCANO PLOT OF THE MAIN RESULTS

6\. TISSUE-SPECIFIC ANALYSIS

6.1. CLEANING, PRE-PROCESSING, PROCESSING AND RESULTS

6.2. VOLCANO PLOTS

1.  SETUP

1.1. SETUP

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/Dyll/Documents/Education/VU_UVA/Internship/Epigenetics/Janssen_Group-UMCUtrecht/Main_Project")
```

1.2. LOAD THE PACKAGES

```{r}
library(dplyr)
library(knitr)
library(tidyverse) 
library(edgeR)
library(limma)
library(EnhancedVolcano)
library(ggrepel)
library(data.table)
library(AnnotationDbi)
library(org.Hs.eg.db)
```

1.4. REUSABLE FUNCTIONS

```{r}
extract_element <- function(strings, index) {
  # Split each string by "." and extract the third element
  element_list <- sapply(strsplit(strings, "\\."), function(x) x[index])
  return(element_list)
}

untransform <- function(x) {#Function to convert the log transformed counts back into original counts
  return(ceiling((2^x)-1))
}
```

2.  COLLECTION

2.1. LOAD THE DATA

```{r}
# Load the TCGA PanCan RSEM Expected Counts
ori_exp <- read.csv("Data/RNA_Data/TCGA_Norm/tcga_gene_expected_count.csv")
order_exp <- ori_exp[,order(colnames(ori_exp))]
order_exp <- order_exp[0:6000,0:2500]

# Load the TCGA PanCan TPM counts
ori_cts <- read.csv("Data/RNA_Data/TCGA_TPM/TCGA_mRNA_TPM_Full.csv")
order_cts <- ori_cts[,order(colnames(ori_cts))] %>% 
  dplyr::select(-"id")
order_cts <- order_cts[0:6000,0:2500]

# Cancer/Tissue Metadata
tss_meta <- read.csv("Data/Other/TCGA_meta/tissueSourceSite.tsv", sep = "\t")
abbrv_meta <- read.csv("Data/Other/TCGA_meta/bcrBatchCode.tsv", sep = "\t")
meta <- left_join(tss_meta %>%
                    dplyr::select(c("TSS.Code", "Study.Name")) %>%
                    distinct() %>%
                    sapply(trimws) %>%
                    as.data.frame(),
                  abbrv_meta %>%
                     dplyr::select(c("Study.Abbreviation", "Study.Name")) %>%
                    distinct()%>%
                    sapply(trimws) %>%
                    as.data.frame(),
                  by = "Study.Name")

# Gene Metadata
gene_ids <- read.delim("Data/Other/TCGA_meta/TCGA_PanCan_TPM_Gene_Annotations.txt")

# SOI genes
soi <- read.csv("Data/RNA_Data/TCGA_TPM/TCGA_mRNA_TPM_SOI.csv")
soi_genes <-soi[,2]
```

3.  CLEANING AND PRE-PROCESSING

3.1. RE-TRANSFORM THE EXPECTED COUNT DATA FROM THE y = Log2(x+1) VALUES TO THE COUNTS USING THE FOLLOWING FORUMLA: x = 2^y^âˆ’1.

```{r}
trans_exp <- order_exp
rownames(trans_exp) <- NULL

count_exp <- trans_exp %>%
  mutate_at(vars(-1), untransform)
```

```{r}
# Remove the non-cancerous sample types from the set
codes_to_use <- c("01","02","03","04","05","08","09")

exp_samples_to_use <- count_exp %>%  dplyr::select(c("sample", ends_with(codes_to_use)))
cts_samples_to_use <- order_cts %>%  dplyr::select(c("Gene", ends_with(codes_to_use)))
```


3.2. CONVERT THE GENE IDS INTO GENE NAMES

```{r}
counts_exp <- right_join(gene_ids %>% 
                    dplyr::select(c("id", "gene")) %>% 
                    sapply(trimws) %>% 
                    as.data.frame(),
                  exp_samples_to_use,
                  by = c("id" = "sample")) %>% 
  dplyr::select(-"id")

counts_exp <- counts_exp %>%
  mutate(gene = trimws(gene))
  
```


HANDLE DUPLICATE GENES
```{r}
# Convert data to a data.table for faster processing during the grouping of the duplicate genes
setDT(counts_exp)  
setDT(cts_samples_to_use)  

# Combine duplicate genes together using the median of the expression
grouped_exp <- counts_exp[, lapply(.SD, function(x) if (length(x) > 1) median(x, na.rm = TRUE) else x), by = gene, .SDcols = -"gene"]
grouped_cts <- cts_samples_to_use[, lapply(.SD, function(x) if (length(x) > 1) median(x, na.rm = TRUE) else x), by = Gene, .SDcols = -"Gene"]

# Edit ids so as to be able to identify the condition
# Reset the row names to the Gene names
groups_exp <- as.data.frame(grouped_exp)
exp_data <- distinct(groups_exp) %>% 
  column_to_rownames(var = "gene")

groups_cts <- as.data.frame(grouped_cts)
cts_data <- distinct(groups_cts) %>% 
  column_to_rownames(var = "Gene")
```



3.4. REMOVAL OF THE UNDESIRABLE GENE & SAMPLES: GENES THAT LACK EXPRESSION COUNTS AND SAMPLES THAT ARE NOT PART OF A HEALTHY/CANCEROUS PAIR.

```{r}
# Remove samples (cols) with 0 values throughout
cols_zeros <- which(apply(mapped_data, 2, function(x) all(x == 0)))
if (length(cols_zeros) > 0) {
  mapped_data_complete <- mapped_data[, -cols_zeros]
} else {
  mapped_data_complete <- mapped_data
}

# Get unique participants
unique_pairs <- unique(participants)

# List of participants with healthy/cancer paired samples
selected_columns <- c()

# Loop through each participant
for (pair in unique_pairs) {
  # Find the participants with healthy/cancer sample pairings
  pairedup <-paste0(".", pair, ".")
  columns_with_pair <- grep(pairedup, colnames(mapped_data_complete))
  matching_columns <- colnames(mapped_data_complete)[columns_with_pair]
  if (length(matching_columns) > 1 && any(grepl("\\.N$", matching_columns)) && any(grepl("\\.C$",matching_columns))) {
    # Add the found participants to the list
    selected_columns <- c(selected_columns, matching_columns)
  }
}

# Filter the data on the list of participants with healthy/cancer paired samples
subset_mapped <- mapped_data_complete[, selected_columns]

```

4.  PROCESSING

4.1. DGE MODELLING: DEFINE THE MATRIX, CREATE ITS DGE OBJECT AND GET THE NORMALISATION FACTORS

```{r}
# convert df to matrix 
 mapped_matrix <- subset_mapped %>% as.matrix()

d0 <- DGEList(mapped_matrix, group = extract_element(colnames(mapped_matrix), 3))
print(paste("The size of the counts dataframe has been reduced from", 
            dim(counts_data)[1], "x", dim(counts_data)[2]," to ", 
            dim(d0)[1], "x", dim(d0)[2]))

# Calculate the normalisation factor 
d0 <- calcNormFactors(d0, method = "TMM")
```

4.2. CREATE THE SAMPLE FACTORS

IMPORTANT: The order of the condition factor will determine how the logFCs are calculated, with the first level representing the reference (denominator) which in this case should be the healthy condition.

```{r}
participants <- extract_element(colnames(mapped_matrix), 2)
condition <- extract_element(colnames(mapped_matrix), 3)
tissue_type <- extract_element(colnames(mapped_matrix), 1)

participants <- factor(participants)
tissue_type <- factor(tissue_type)
condition <- factor(condition, levels=c("N","C"))
```

4.3. TRIM LOW COUNT GENES

```{r}
# Remove low count genes, those with a count below 10
keep<-filterByExpr(d0,group = condition, min.count = 10)
d0<-d0[keep,,keep.lib.size=FALSE]

print(paste("The size of the dataframe is now", 
            dim(d0)[1], "x", dim(d0)[2]))
```

4.4. PLOT THE MDS OF THE FACTORS

Plot the 2 dimensional graph of the main logFC components in terms of the condition

```{r}
plotMDS(d0, pch = 1, col = ifelse(condition == "C", "red", "blue"))
```

Plot the 2 dimensional graph of the main logFC components in terms of the tissue type

```{r}
plotMDS(d0, pch = 3, col = tissue_type)
```

4.5. CREATE THE LINEAR MODEL

```{r}
# Set the unique participants and the condition as the main effects.
mm <- model.matrix(~ participants + condition)
```

```{r}
# Apply voom() to transfrom the data so that it is suitable for linear modelling.
y <- voom(d0, mm, plot = T)

# Fit the linear model
fit <- lmFit(y, mm)

# smooth the standard errors
fit2 <- eBayes(fit)
```

5.  COMPLETE RESULTS

5.1. PRODUCE THE RESULTS TABLE

Get the table of all the genes and their fold changes and significance

```{r}
express_table <- topTable(fit2, coef="conditionC", sort.by = "P", n = Inf)

write.csv(express_table, "DGEA_ALLGENES_ALLTISSUES_expression_table.csv", row.names=TRUE)
```

5.2. CREATE THE VOLCANO PLOT OF THE MAIN RESULTS

Plot the volcano plot highlighting the GOIs

```{r}

keyvals1 <- ifelse(
    rownames(express_table) %in% soi_genes, 'red2',
        '#8B8B83') 
  keyvals1[is.na(keyvals1)] <- 'black'
  names(keyvals1)[keyvals1 == 'red2'] <- 'Gene of Interest'
  names(keyvals1)[keyvals1 == '#8B8B83'] <- 'Other'
  
  
usable_volcano <- EnhancedVolcano(express_table,
                lab = rownames(express_table),
                x = "logFC",
                y = "P.Value",
                title = "TCGA Differential Gene Expression",
                subtitle = "Combined Tissue Types",
                selectLab = soi_genes,
                colCustom = keyvals1,
                pointSize = c(ifelse(rownames(express_table) %in% soi_genes, 4, 1)),
                xlim = c(min(express_table %>%
                               filter(rownames(express_table) %in% soi_genes) %>%
                               pull(logFC)),
                         max(express_table %>%
                      filter(rownames(express_table) %in% soi_genes) %>%
                      pull(logFC))),
                ylim = c(0,
                         -log10(min(express_table %>%
                               filter(rownames(express_table) %in% soi_genes) %>%
                               pull(P.Value)))),
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colAlpha = 0.65,
                pCutoff = 0.01,
                FCcutoff = 1,
                labSize = 5,
                max.overlaps = 25,
                min.segment.length = 0.1)
usable_volcano

pdf(paste0(loc,"DGEA_VOLCANO_COMPLETE.pdf"))
usable_volcano
dev.off()

```

6.  TISSUE-SPECIFIC ANALYSIS

6.1. CLEANING, PRE-PROCESSING, PROCESSING AND RESULTS OF THE TISSUE SPECIFIC ANALYSIS

Loop over the distinct tissue/cancer types and perform the DGE

```{r}

full_expression_table <- data.frame()

distinct_tissue_types <- unique(extract_element(colnames(subset_mapped), 1))

plotlist <- list()

for (type in distinct_tissue_types) {
  type_cols <- grep(paste0("^", type), colnames(subset_mapped), value = TRUE)
  specific_data <- subset_mapped %>% dplyr::select(all_of(type_cols))

  col_number <- ncol(specific_data)
  if (col_number < 2) {
    next
  }

  # convert df to matrix
  specific_matrix <- specific_data %>% as.matrix()

  specific_d <- DGEList(specific_matrix, group = extract_element(colnames(specific_matrix), 3))

  # Calculate the normalisation factor
  specific_d <- calcNormFactors(specific_d, method = "TMM")

  # Create a factor for the variables
  participants <- extract_element(colnames(specific_matrix), 2)
  condition <- extract_element(colnames(specific_matrix), 3)
  participants <- factor(participants)
  condition <- factor(condition, levels=c("N","C"))

  # Remove low count genes, those with a count below 10
  print(paste("The size of the ", type, " dataframe was", dim(specific_d)[1], "x", dim(specific_d)[2]))
  keep <- filterByExpr(specific_d, group = condition, min.count = 10)
  specific_d <- specific_d[keep,, keep.lib.size = FALSE]
  print(paste("The size of the ", type, " dataframe is now", dim(specific_d)[1], "x", dim(specific_d)[2]))

  plotMDS(specific_d, pch = 1, col = ifelse(condition == "C", "red", "blue"), top = 25)

  # Set the unique participants and the condition as the main effects.
  specific_mm <- model.matrix(~ participants + condition)

  # Apply voom() to transform the data so that it is suitable for linear modelling.
  specific_y <- voom(specific_d, specific_mm, plot = FALSE)

  # Fit the linear model
  specific_fit <- lmFit(specific_y, specific_mm)

  # smooth the standard errors
  specific_smoothed <- eBayes(specific_fit)

  specific_express_table <- topTable(specific_smoothed, coef="conditionC", sort.by = "P", n = Inf) %>% 
    dplyr::select(c("logFC", "AveExpr", "P.Value", "adj.P.Val", "B"))
  specific_express_table$Tissue <- type

  # Extract row names
  row_names <- rownames(specific_express_table)

  # Add row names as a new column to the data frame and move it to the first position
  specific_express_table <- specific_express_table %>%
    mutate(Genes = row_names) %>%
    dplyr::select(Genes, everything())

  # Add the current DGE table to the full table
  full_expression_table <- rbind(full_expression_table, specific_express_table)

  keyvals <- ifelse(
    specific_express_table$Genes %in% soi_genes, 'red2', '#8B8B83')
  keyvals[is.na(keyvals)] <- 'black'
  names(keyvals)[keyvals == 'red2'] <- 'Gene of Interest'
  names(keyvals)[keyvals == '#8B8B83'] <- 'Other'
  
  
  xmini <- min(specific_express_table %>%
                filter(specific_express_table$Genes %in% soi_genes) %>%
                pull(logFC))
  
  xmaxi <- max(specific_express_table %>%
                filter(specific_express_table$Genes %in% soi_genes) %>%
                pull(logFC))
  
  ymaxi <- -log10(min(specific_express_table %>%
                filter(specific_express_table$Genes %in% soi_genes) %>%
                pull(logFC)))

  specific_volcano <- EnhancedVolcano(specific_express_table,
                                       lab = specific_express_table$Genes,
                                       x = "logFC",
                                       y = "P.Value",
                                       title = "TCGA Differential Gene Expression",
                                       subtitle = paste0(type, " Subset"),
                                       selectLab = soi_genes,
                                       colCustom = keyvals,
                                       pointSize = c(ifelse(specific_express_table$Genes %in% soi_genes, 3, 1)),
                                       xlim = c(xmini-2, xmaxi+2),
                                       ylim = c(0,ymaxi + 10/ymaxi),
                                       drawConnectors = TRUE,
                                       widthConnectors = 0.2,
                                       colAlpha = 0.65,
                                       pCutoff = 0.01,
                                       FCcutoff = 1,
                                       labSize = 5,
                                       max.overlaps = 25,
                                       min.segment.length = 0.1) 

  pdf(paste0(loc, "DGEA_VOLCANO_", type, ".pdf"))
  print(specific_volcano)  # Print the plot to the PDF
  dev.off()  # Close the PDF device

  name <- paste0(type, "_volcano")
  assign(name, specific_volcano)
}

```

Interpretation:

```{r}
write.csv(full_expression_table, "DGEA_ALLGENES_BYTISSUE_XPRSS_TBL.csv", row.names=TRUE)
```

6.2 VOLCANO PLOTS

Create the volcano plots for the group of tissues that are of most interest

```{r}
  
usable_tissues <- c("BRCA", "COAD", "HNSC", "KICH", "KIRC", "KIRP","LIHC", "LUAD", "LUSC", "PRAD", "STAD", "THCA")

usable_tissues_expression <- full_expression_table %>% filter(Tissue %in% usable_tissues)

keyvals2 <- ifelse(
  usable_tissues_expression$Genes %in% soi_genes, 'red2','#8B8B83')
  keyvals2[is.na(keyvals2)] <- 'black'
  names(keyvals2)[keyvals2 == 'red2'] <- 'Gene of Interest'
  names(keyvals2)[keyvals2 == '#8B8B83'] <- 'Other'
  
usable_tissues_expression_volcano <- EnhancedVolcano(usable_tissues_expression ,
                lab = usable_tissues_expression$Genes,
                x = "logFC",
                y = "P.Value",
                title = "TCGA Differential Gene Expression",
                subtitle = " n>10 type Samples",
                selectLab = soi_genes,
                colCustom = keyvals2,
                pointSize = c(ifelse(usable_tissues_expression$Genes %in% soi_genes,8, 3.5)),
                drawConnectors = TRUE,
                widthConnectors = 0.2,
                colAlpha = 0.65,
                pCutoff = 0.01,
                xlim = c(min(usable_tissues_expression %>%
                               filter(Genes %in% soi_genes) %>%
                               pull(logFC)),
                         max(usable_tissues_expression %>%
                      filter(Genes %in% soi_genes) %>%
                      pull(logFC))),
                ylim = c(0,
                         -log10(min(usable_tissues_expression %>%
                               filter(Genes %in% soi_genes) %>%
                               pull(P.Value)))),
                FCcutoff = 1,
                labSize = 8.5,
                max.overlaps = 25,
                min.segment.length = 0.1) +
  facet_wrap(~Tissue, scales = "free") +
  theme(strip.text = element_text(size = 15))


png(paste0(loc, "DGEA_VOLCANO_10TSS.png"), width = 3040, height = 2060)
print(usable_tissues_expression_volcano)  # Print the plot to the PDF
dev.off()  # Close the PDF device


tissues_of_interest <- c("BRCA", "HNSC", "LIHC", "LUSC")

tissues_of_interest_expression <- full_expression_table %>% filter(Tissue %in% tissues_of_interest)

keyvals3 <- ifelse(
  tissues_of_interest_expression$Genes %in% soi_genes, 'red2','#8B8B83')
  keyvals3[is.na(keyvals3)] <- 'black'
  names(keyvals3)[keyvals3 == 'red2'] <- 'Gene of Interest'
  names(keyvals3)[keyvals3 == '#8B8B83'] <- 'Other'

tissues_of_interest_expression_volcano <- EnhancedVolcano(tissues_of_interest_expression ,
                lab = tissues_of_interest_expression$Genes,
                x = "logFC",
                y = "P.Value",
                title = "TCGA Differential Gene Expression",
                subtitle = " n>10 type Samples",
                selectLab = soi_genes,
                colCustom = keyvals3,
                pointSize = c(ifelse(tissues_of_interest_expression$Genes %in% soi_genes, 8, 3.5)),
                drawConnectors = TRUE,
                widthConnectors = 0.25,
                colAlpha = 0.65,
                pCutoff = 0.01,
                xlim = c(min(usable_tissues_expression %>%
                               filter(Genes %in% soi_genes) %>%
                               pull(logFC))+0.2,
                         max(usable_tissues_expression %>%
                      filter(Genes %in% soi_genes) %>%
                      pull(logFC))-0.2),
                ylim = c(0,
                         -log10(min(usable_tissues_expression %>%
                               filter(Genes %in% soi_genes) %>%
                               pull(P.Value)))+2),
                FCcutoff = 1,
                labSize = 8.5,
                max.overlaps = 25,
                min.segment.length = 0.1) +
  facet_wrap(~Tissue, scales = "free") +
  theme(strip.text = element_text(size = 15))

png(paste0(loc, "DGEA_VOLCANO_4TSS.png"), width = 3840, height = 2160)
print(tissues_of_interest_expression_volcano)  # Print the plot to the PDF
dev.off()  # Close the PDF device

```
