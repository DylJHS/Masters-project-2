---
title: "TCGA_RNA_SIGNATURE_HIERARCHIAL_CLUSTER_METHOD"
format: html
editor: visual
Note: This script is for the creation of the gene signatures using the metagene clustering approach.
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/Dyll/Documents/Education/VU_UVA/Internship/Epigenetics/Janssen_Group-UMCUtrecht/Main_Project")
```

PACKAGES

```{r}
library(dplyr)
library(knitr)
library(tidyverse) 
library(paletteer)
library(ggrepel)
library(ggplot2)
library(pheatmap)
library(Hmisc)
library(dendextend)
```

REUSABLE FUNCTIONS

```{r}
extract_element <- function(strings, index) {
  # Split each string by "." and extract the third element
  element_list <- sapply(strsplit(strings, "\\."), function(x) x[index])
  return(element_list)
}

inter_coef <- function(x) {
  # Inter-cluster coefficient calculation
  x_squared <- x^2
  non_neg <- x >= 0
  x * x_squared * non_neg + 1 * x_squared * (!non_neg)
}
  
sigmoid <- function(x,s = sig_sens,m = sig_m) {
  1 / (1 + exp(-s * (x - m)))
}
```

PARAMETERS
```{r}
lambda = 2 # ICSS negative cor penalty multiplier
alpha = 0.9 # ICDS scaling factor to adjust the sensitivity to differences between clusters (lower = more sensitive)
sig_m = 0.7 # sigmoid midpoint, the inflection point of r at which the scaling converts from negative (y < r) to positive (y > r)
sig_sens = 15 # sensitivity of the sigmoid function to r (higher = more sensitive)
weight = 0.6 # the weight that is given to the ICSS
```

### 1. COLLECT DATASETS

1.1 LOAD THE RNASEQ DATASETS

```{r}
# Metadata
tss_meta <- read.csv("Data/Other/TCGA_meta/tissueSourceSite.tsv", sep = "\t")
abbrv_meta <- read.csv("Data/Other/TCGA_meta/bcrBatchCode.tsv", sep = "\t")

# Set of Interest TPM data
full_soi <- read.csv("Data/RNA_Data/TCGA_TPM/TCGA_mRNA_TPM_SOI.csv")
soi <- full_soi[-1]
# soi <- soi[0:50,0:50]
```

1.2 ORGANISE THE DATAFRAMES

```{r}

# Combine the metadata
meta <- left_join(tss_meta %>% 
                     select(c("TSS.Code", "Study.Name")) %>% 
                     distinct() %>% 
                     sapply(trimws) %>% 
                     as.data.frame(),
                   abbrv_meta %>%
                     select(c("Study.Abbreviation", "Study.Name")) %>% 
                     distinct()%>% 
                     sapply(trimws) %>% 
                     as.data.frame(), 
                   by = "Study.Name")

```

### 2. CLEAN & PRE-PROCESS THE DATA

2.1 EDIT THE SAMPLE NAMES (COLUMN NAMES) INTO IDS SO AS TO BE ABLE TO IDENTIFY THE PARTICIPANT AND THE CANCER TYPE

```{r}
ids <- colnames(soi)[-1]
participants <- extract_element(ids, 3)
condition <- extract_element(ids, 4)
tissue_type <- extract_element(ids, 2)

column_names <- c("Gene" ,  paste(tissue_type, participants, condition, sep = "."))
colnames(soi) <- column_names
```

2,4 REMOVE THE UNVIABLE SAMPLES FROM THE DATA

```{r}
# Remove the unwanted sample types from the samples based on the code
codes_to_use <- c("01","02","03","04","05","08","09")
viable_soi <- soi %>%  dplyr::select("Gene" | ends_with(codes_to_use))
```

2.3 FORMAT THE DF

```{r}
# Summarise the duplicate genes by their mean
log_data <- viable_soi %>% 
  group_by(Gene) %>%
  summarise(across(everything(), ~mean(., na.rm = TRUE)))

# Set the Gene column as the rownames
# and transpose the df so rows become the columns
xprss_df <- log_data %>%
  column_to_rownames(var = "Gene") %>% 
  t()
```

### 3. PROCESSING

3.1 CORRELATION MATRIX CREATION

```{r}
# Calculate the correlation matrix 
cor_mtrx_xprss <- cor(xprss_df) # correlation matrix

# Set the breakpoint where the change in color will occur 
myBreaks <- c(seq(-1, 0.749, length.out = 100), seq(0.750, 1, length.out = 100))
myColors <- colorRampPalette(c("blue1", "white","red4"))(length(myBreaks) - 1)

# Create and save the resulting heatmap
cor_hmap_xprss <- pheatmap(cor_mtrx_xprss, color = myColors, breaks = myBreaks, border_color = NA)
ggsave("Plots/full_heatmap.png",   
       plot = cor_hmap_xprss,
       width = 30,
       height = 25)
```

3.2 DISTANCE MATRIX CREATION

```{r}
# Create the distance matrix
dist_mtrx_xprss <- as.dist(1 - cor_mtrx_xprss) # dissimilarity matrix
xprss_dist_df <- as.data.frame(as.matrix(dist_mtrx_xprss)) # dissimilarity df

# Create the resulting distance heatmap
hmap_dist_mtrx <- pheatmap(dist_mtrx_xprss, border_color = NA)
```

3.3 DENDROGRAM GENERATION

```{r}
# Cluster the Genes using the average distance and
# extract the dendrogram from the matrix 
dist_tree_xprss <- hclust(dist_mtrx_xprss, method="average") %>%
  as.dendrogram()

# Get the different heights that show up in the tree
# and sort them
node_hts <- dist_tree_xprss %>% 
  get_nodes_attr("height") %>% 
  unique() %>% 
  sort()

# Plot the tree
dist_tree_xprss %>% dendextend::set("labels_cex", 0.4) %>% plot()
```

3.4 HEIGHT BASED CLUSTERING OPTIMISATION

```{r}
# Set the breakpoints for the corr matrix where the change in color will occur 
newBreaks <- c(seq(-1, 0.00, length.out = 100), seq(0.01, 1, length.out = 100))

# Initialise the df that will contain the coef Score, Node height, Number of groups formed
scoring_df <- data.frame(Iteration = integer(),
                                ICSS = numeric(),
                                ICDS = numeric(),
                                TCSS = numeric(),
                                Node.Heightt = numeric(),
                                Cluster.Count = integer())

# Initialise the scores 
initial_ICSS <- 1
initial_ICDS <- sum((1 - abs(cor_mtrx_xprss) / (alpha))) / length(cor_mtrx_xprss)
tot_score <- weight*initial_ICSS + (1-weight)*initial_ICDS

scoring_df <- rbind(
    scoring_df,
    data.frame(Iteration = 1,
               Intra.Score = initial_ICSS,
               Inter.Score = initial_ICDS,
               Total.Score = tot_score,
               Node.Height = 0,
               Cluster.Count = 0
               )
    )
```

```{r}
# Iterate over the differnet node heights
for (ht in seq(2,length(node_hts)-1)){
  # Select the cut height 
  cut.ht = node_hts[ht]

  
  # Get the resulting dendrogram
  clusters <- cutree(dist_tree_xprss, h = cut.ht)

  # Get the genetic makeup of each cluster
  cluster_df <- as.data.frame(clusters)%>%
  rownames_to_column("Gene")
  
  # Get the number of groups
  n_groups <- length(unique(clusters))

  # Add this iteration's cluster information to the expression matrix
  xprss_df_clustered <- left_join(log_data,
                   cluster_df,
                   by = "Gene") %>% 
    mutate(n_genes = map_dbl(clusters, 
                             ~sum(.x == clusters, na.rm = TRUE)
                             ), # number of genes in the cluster
           Cluster.Name = ifelse(n_genes == 1, Gene, 
                                 paste0("Clust.",clusters))) %>% 
    select(-c("clusters","n_genes"))
  
  # Group the expression matrix in terms of the clusters
  grouped_xprss_df_clustered <- xprss_df_clustered %>% 
    group_by(Cluster.Name) %>%
    summarise(across(-Gene, ~ mean(., na.rm = TRUE))) 
  
  
  # Intra Cluster Similarity Score (ICSS)
  
  # Find the clusters with more than a single gene occupant
  filled_clusters <- grouped_xprss_df_clustered %>% 
    filter(str_detect(Cluster.Name, "^Clust.")) %>% 
    pull(Cluster.Name) 
  
   # The number of unclustered genes 
  n_unclust_genes <- n_groups - length(filled_clusters)
  
  # Iterate over each cluster to calculate its specific similarity score
  total_intra_score <- 0
  
  # Filter over these individual clusters creating the cluster specific corr matrix
  for (clust in filled_clusters){
    intra_corr <- xprss_df_clustered %>% 
      filter(Cluster.Name == clust) %>% 
      select(-Cluster.Name) %>% 
      column_to_rownames("Gene") %>% 
      t() %>% 
      cor()
    
    # Sum positive correlations
    positive_contrib <- sum((intra_corr > 0) * 
                             sigmoid(intra_corr))
    
    # Sum negative correlations
    negative_contrib <- sum((intra_corr < 0) * 
                             sigmoid(abs(intra_corr)))
    
    # Get the number of gene pairs
    n_pairs <- length(intra_corr)
    
    # Calculate cluster score and adjust by the number of pairs
    cluster_score <- (positive_contrib - lambda * negative_contrib) / n_pairs
    
    # Add to total score
    total_intra_score <- total_intra_score + cluster_score
  }
  
  # Add the score of the unclustered genes
  total_intra_score <- total_intra_score + n_unclust_genes
  
  # Average the score by the number of clusters
  ICSS <- total_intra_score / n_groups

 
  # Inter Cluster Dissimilarity Score, ICDS

  # Redefine the correlation matrix in terms of the clusters
  reclustered_matrix <- grouped_xprss_df_clustered %>%
    column_to_rownames("Cluster.Name") %>%
    t() %>%
    cor(., method = "pearson")
  
  ICDS <- sum((1 - abs(reclustered_matrix) / (alpha))) / length(reclustered_matrix)
  
  
  # Total Cluster Correlation Score (TCCS)

  TCCS <- weight*ICSS + (1 - weight)*ICDS


  # Collect the Scores from the different iterations

  scoring_df <- rbind(
    scoring_df,
    data.frame(Iteration = ht,
               Intra.Score = ICSS,
               Inter.Score = ICDS,
               Total.Score = TCCS,
               Node.Height = cut.ht,
               Cluster.Count = length(filled_clusters)
               )
    )
  
  clust_heatmap <- pheatmap(reclustered_matrix,
                            breaks = newBreaks ,
                            color = myColors,
                            border_color = NA)

  # Save the heatmaps
  ggsave(paste0("Plots/clustered_hmap_", ht, ".png"),
       plot = clust_heatmap,
       width = 30,
       height = 25)
  
}
```


```{r}
# locate the iteration with the greatest total combined score (TCCS)
# use the node height to render the matrix, clusters & extract the tree 

optimal_node_ht <- scoring_df %>%
  filter(Total.Score == max(Total.Score)) %>% 
    pull(Node.Height) 

# Get the resulting dendrogram
optimal_dendro <- cutree(dist_tree_xprss, h = optimal_node_ht)

# Get the genetic makeup of each cluster
optimal_clusters <- as.data.frame(optimal_dendro)%>%
  rownames_to_column("Gene")
  
# Get the number of groups
n_groups <- length(unique(clusters))

# Add this iteration's cluster information to the expression matrix
xprss_df_clustered <- left_join(log_data,
                                optimal_clusters,
                                by = "Gene") %>% 
  mutate(n_genes = map_dbl(optimal_clusters, 
                           ~sum(.x == optimal_clusters, na.rm = TRUE)
                           ), # number of genes in the cluster
         Cluster.Name = ifelse(n_genes == 1, Gene, 
                               paste0("Clust.",optimal_clusters))) %>%
  select(-c("clusters","n_genes"))
  
  # Group the expression matrix in terms of the clusters
  grouped_xprss_df_clustered <- xprss_df_clustered %>% 
    group_by(Cluster.Name) %>%
    summarise(across(-Gene, ~ mean(., na.rm = TRUE))) 
  


  # # Plot the resulting tree
  # plot(color_branches(distance.tree, h=cut.ht),
  #      leaflab="none",
  #      col = paletteer_c("grDevices::Terrain 2",
  #                        length(unique(clusters))),
  #      main = " Hierarchical clustering (average method)"
  #      )
  # abline(h = cut.ht, col = "red", lwd = 0.75)
  # mtext(paste0("Cut Height of ",round(cut.ht, 2),
  #              ", yeilding ",
  #              n_clusters,
  #              " clusters"
  #              ),
  #       side = 3,
  #       line = 0.5,
  #       cex = 0.8,
  #       adj = 0.5
  #       )
```
